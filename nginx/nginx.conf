events {}

http {
    upstream service1 {
        server service-1:8080;
    }

    upstream service2 {
        server service-2:8080;
    }

    upstream stateservice {
        server state-service:8080;
    }

    server {
        listen 80;
        set $service_start_time $date_local;

        location /service-start-time {
            add_header Content-Type text/plain;
            return 200 "$service_start_time";
        }

        location / {
            content_by_lua_block {
                local upstream = require("ngx.upstream")
                local http = require("resty.http")
                local httpc = http.new()
                
                local stateservice = upstream.get_servers("stateservice")
                for _, srv in ipairs(stateservice) do
                    local res, err = httpc:request_uri("http://" .. srv.addr .. "/state", { method = "GET" })

                    if not res or res.status ~= 200 then
                        ngx.log(ngx.ERR, "Failed to fetch state: ", err)
                        ngx.exit(500)
                    end

                    if res.body == "INIT" then
                        ngx.exec("/login.html")
                    else
                        ngx.exec("/index.html")
                    end
                end
            }
        }

        location /service1 {
            content_by_lua_block {
                local res = ngx.location.capture("/internal_state")
                
                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "Failed to fetch state, status: ", res.status)
                    ngx.exit(500)
                end

                if res.body == "RUNNING" then
                    local request_count_res = ngx.location.capture("/internal_request_count_browser", { method = ngx.HTTP_PUT })
                    
                    if request_count_res.status ~= 204 then
                        ngx.log(ngx.ERR, "Failed to update request count: ", request_count_res.body, "Status: ", request_count_res.status)
                        ngx.exit(500)
                    end

                    ngx.exec("/internal_service1")
                else
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say("Request is forbidden unless state is RUNNING. Wait for system state change or refresh page to login if possible")
                    ngx.exit(ngx.HTTP_FORBIDDEN)
                end
            }
        }

        
        location /shutdown {
            content_by_lua_block {
                local res = ngx.location.capture("/internal_state")

                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "Failed to fetch state, status: ", res.status)
                    ngx.exit(500)
                end

                if res.body == "RUNNING" then
                    ngx.exec("/internal_shutdown")
                else
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say("Shutdown is forbidden unless state is RUNNING. Wait for system state change or or refresh page to login if possible.")
                    ngx.exit(ngx.HTTP_FORBIDDEN)
                end
            }
        }
        
        location /auth/verify {
            proxy_pass http://stateservice/auth/verify;
        }
        
        location /request-count {
            limit_except GET {
                deny all;
            }
            proxy_pass http://stateservice/request-count;
        }
        
        location /login.html {
            internal;
            root /usr/share/nginx/html;
        }

        location /index.html {
            internal;
            root /usr/share/nginx/html;
        }

        location /internal_request_count_browser {
            internal;
            proxy_pass http://stateservice/request-count/browser;
        }

        location /internal_state {
            internal;
            proxy_pass http://stateservice/state;
        }

        location /internal_service1 {
            internal;
            proxy_pass http://service1/;
        }

        location /internal_shutdown {
            internal;

            proxy_set_header Host 127.0.0.1;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://localhost:81/shutdown;
        }
    }

    server {
        listen 81;
        set $test_env ${TEST_ENV};

        location /request {
            content_by_lua_block {
                local res = ngx.location.capture("/internal_request_count_api", { method = ngx.HTTP_PUT })
                
                if res.status ~= 204 then
                    ngx.log(ngx.ERR, "Failed to update request count: ", res.body, "Status: ", res.status)
                    ngx.exit(500)
                end

                ngx.exec("/internal_service1")
            }
        }

        location /state {
            limit_except GET PUT {
                deny all;
            }
            proxy_pass http://stateservice/state;
        }

        location /run-log {
            proxy_pass http://stateservice/run-log;
        }

        location /state/running {
            if ($test_env != true) {
                return 404;
            }
            
            proxy_pass http://stateservice/state/running;
        }

        location /request-count {
            if ($test_env != true) {
                return 404; 
            }
            
            proxy_pass http://stateservice/request-count;
        }

        location /internal_service1 {
            internal;
            proxy_pass http://service1/;
        }

        location /internal_request_count_api {
            internal;
            proxy_pass http://stateservice/request-count/api;
        }

        location /shutdown {
            allow 127.0.0.1;
            allow 172.18.0.0/16;
            deny all;

            content_by_lua_block {
                local upstream = require("ngx.upstream")
                local http = require("resty.http")
                local httpc = http.new()

                local servers = upstream.get_servers("service1")
                for _, srv in ipairs(servers) do
                    for _, a in ipairs(srv.addr) do
                        httpc:request_uri("http://" .. a .. "/shutdown", { method = "POST" })
                    end
                end

                local servers2 = upstream.get_servers("service2")
                for _, srv in ipairs(servers2) do
                    httpc:request_uri("http://" .. srv.addr .. "/shutdown", { method = "POST" })
                end

                local stateservice = upstream.get_servers("stateservice")
                for _, srv in ipairs(stateservice) do
                    httpc:request_uri("http://" .. srv.addr .. "/shutdown", { method = "POST" })
                end

                os.execute("sudo /var/data/shutdown.sh")
            }
        }
    }
}